name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "deploy-production" to confirm'
        required: true
        default: ''

env:
  NODE_VERSION: '20.x'

jobs:
  validate-deployment:
    name: Validate Deployment Request
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'

    steps:
      - name: Validate confirmation
        run: |
          if [ "${{ github.event.inputs.confirm }}" != "deploy-production" ]; then
            echo "❌ Deployment not confirmed. Please type 'deploy-production' to proceed."
            exit 1
          fi
          echo "✅ Deployment confirmed"

  pre-deployment-checks:
    name: Pre-Deployment Checks
    runs-on: ubuntu-latest
    needs: validate-deployment
    if: always() && !cancelled()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run security audit
        run: npm audit --audit-level=high

      - name: Run type checking
        run: npm run type-check

      - name: Run linter
        run: npm run lint

      - name: Run full test suite
        run: npm run test
        env:
          CI: true

      - name: Check for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD

  build:
    name: Build Production Application
    runs-on: ubuntu-latest
    needs: pre-deployment-checks

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build for production
        run: npm run build:prod
        env:
          VITE_SUPABASE_URL: ${{ secrets.PROD_SUPABASE_URL }}
          VITE_SUPABASE_ANON_KEY: ${{ secrets.PROD_SUPABASE_ANON_KEY }}
          VITE_APP_ENV: production
          VITE_APP_URL: ${{ secrets.PROD_APP_URL }}

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: production-dist
          path: dist/
          retention-days: 30

      - name: Generate build info
        run: |
          echo "Build Date: $(date)" > dist/build-info.txt
          echo "Commit: ${{ github.sha }}" >> dist/build-info.txt
          echo "Branch: ${{ github.ref }}" >> dist/build-info.txt
          echo "Version: ${{ github.event.release.tag_name || 'manual' }}" >> dist/build-info.txt

  database-migration:
    name: Run Database Migrations
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    environment:
      name: production
      url: ${{ secrets.PROD_APP_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link to Production Project
        run: supabase link --project-ref ${{ secrets.PROD_SUPABASE_PROJECT_REF }}
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Backup database
        run: |
          echo "Creating database backup..."
          supabase db dump > backup-$(date +%Y%m%d-%H%M%S).sql
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Run migrations
        run: supabase db push
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

  deploy-edge-functions:
    name: Deploy Supabase Edge Functions
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, database-migration]
    environment:
      name: production
      url: ${{ secrets.PROD_APP_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Supabase CLI
        uses: supabase/setup-cli@v1
        with:
          version: latest

      - name: Link to Production Project
        run: supabase link --project-ref ${{ secrets.PROD_SUPABASE_PROJECT_REF }}
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Deploy Edge Functions
        run: supabase functions deploy
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

      - name: Update Edge Function Secrets
        run: |
          supabase secrets set \
            OPENAI_API_KEY="${{ secrets.PROD_OPENAI_API_KEY }}" \
            TWILIO_ACCOUNT_SID="${{ secrets.PROD_TWILIO_ACCOUNT_SID }}" \
            TWILIO_AUTH_TOKEN="${{ secrets.PROD_TWILIO_AUTH_TOKEN }}" \
            AGORA_APP_ID="${{ secrets.PROD_AGORA_APP_ID }}" \
            AGORA_APP_CERTIFICATE="${{ secrets.PROD_AGORA_APP_CERTIFICATE }}"
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}

  deploy-frontend:
    name: Deploy Frontend to Production
    runs-on: ubuntu-latest
    needs: [build, database-migration, deploy-edge-functions]
    environment:
      name: production
      url: ${{ secrets.PROD_APP_URL }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v3
        with:
          name: production-dist
          path: dist/

      - name: Deploy to Vercel
        uses: amondnet/vercel-action@v25
        id: deploy-vercel
        with:
          vercel-token: ${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: ${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
          working-directory: ./

      - name: Set deployment URL
        id: deployment
        run: echo "url=${{ steps.deploy-vercel.outputs.preview-url }}" >> $GITHUB_OUTPUT

  post-deployment-tests:
    name: Post-Deployment Verification
    runs-on: ubuntu-latest
    needs: deploy-frontend

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for deployment to be ready
        run: |
          echo "Waiting 60 seconds for deployment to stabilize..."
          sleep 60

      - name: Health check
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ secrets.PROD_APP_URL }})
          if [ $response -ne 200 ]; then
            echo "❌ Health check failed with status code: $response"
            exit 1
          fi
          echo "✅ Health check passed!"

      - name: Test critical endpoints
        run: |
          # Test Supabase connection
          curl -f -X GET "${{ secrets.PROD_SUPABASE_URL }}/rest/v1/" \
            -H "apikey: ${{ secrets.PROD_SUPABASE_ANON_KEY }}" || exit 1
          
          echo "✅ API endpoints are responsive!"

      - name: SSL/TLS check
        run: |
          curl -vI ${{ secrets.PROD_APP_URL }} 2>&1 | grep "SSL certificate verify ok" || exit 1
          echo "✅ SSL certificate is valid!"

      - name: Performance check
        run: |
          # Check response time (should be < 2 seconds)
          response_time=$(curl -o /dev/null -s -w '%{time_total}\n' ${{ secrets.PROD_APP_URL }})
          if (( $(echo "$response_time > 2" | bc -l) )); then
            echo "⚠️ Warning: Response time is high: ${response_time}s"
          else
            echo "✅ Response time is good: ${response_time}s"
          fi

  smoke-tests:
    name: Run Production Smoke Tests
    runs-on: ubuntu-latest
    needs: post-deployment-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Install Playwright
        run: npx playwright install --with-deps

      - name: Run smoke tests
        run: npm run test:e2e -- --grep @smoke
        env:
          BASE_URL: ${{ secrets.PROD_APP_URL }}
          TEST_USER_EMAIL: ${{ secrets.PROD_TEST_USER_EMAIL }}
          TEST_USER_PASSWORD: ${{ secrets.PROD_TEST_USER_PASSWORD }}

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: smoke-test-results
          path: playwright-report/

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [post-deployment-tests, smoke-tests]
    if: failure()

    steps:
      - name: Notify of failure
        run: echo "❌ Deployment tests failed. Manual rollback may be required."

      - name: Trigger rollback (Vercel)
        run: |
          echo "To rollback, run: vercel rollback [deployment-url]"
          # Automatic rollback can be implemented here

  create-release-notes:
    name: Create Release Notes
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: success()

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        uses: mikepenz/release-changelog-builder-action@v4
        with:
          configuration: ".github/changelog-config.json"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update release notes
        if: github.event_name == 'release'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: context.payload.release.id,
              body: ${{ steps.changelog.outputs.changelog }}
            });

  notify:
    name: Send Production Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy-frontend, post-deployment-tests, smoke-tests]
    if: always()

    steps:
      - name: Determine deployment status
        id: status
        run: |
          if [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "status=✅ SUCCESS" >> $GITHUB_OUTPUT
            echo "color=good" >> $GITHUB_OUTPUT
          else
            echo "status=❌ FAILED" >> $GITHUB_OUTPUT
            echo "color=danger" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          custom_payload: |
            {
              attachments: [{
                color: '${{ steps.status.outputs.color }}',
                text: `🚀 Production Deployment ${{ steps.status.outputs.status }}\n\nVersion: ${{ github.event.release.tag_name || 'manual' }}\nCommit: ${{ github.sha }}\nDeployed by: ${{ github.actor }}\nURL: ${{ secrets.PROD_APP_URL }}`
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}

      - name: Send email notification
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.EMAIL_USERNAME }}
          password: ${{ secrets.EMAIL_PASSWORD }}
          subject: '🚨 Production Deployment Failed - MindBoom 3.0'
          to: ${{ secrets.ALERT_EMAIL }}
          from: 'MindBoom CI/CD <noreply@mindboom.com>'
          body: |
            Production deployment failed!
            
            Version: ${{ github.event.release.tag_name || 'manual' }}
            Commit: ${{ github.sha }}
            Actor: ${{ github.actor }}
            
            Please review the deployment logs and take appropriate action.
            
            Deployment URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

  update-status-page:
    name: Update Status Page
    runs-on: ubuntu-latest
    needs: [smoke-tests]
    if: success()

    steps:
      - name: Update status
        run: |
          echo "Deployment successful - update status page here"
          # Integration with status page service (e.g., StatusPage.io, Uptime Robot)

